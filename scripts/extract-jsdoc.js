#!/usr/bin/env node
// scripts/extract-jsdoc.js

import { parse } from 'comment-parser'
import { promises as fs } from 'fs'
import globby from 'globby'

async function extract () {
  const files = await globby('src/**/*.js')
  let md = '# Project Architecture\n\n_This file is auto-generated by scripts/extract-jsdoc.js_\n\n'

  for (const file of files) {
    const content = await fs.readFile(file, 'utf8')
    const blocks = parse(content, { spacing: 'preserve' })
    if (blocks.length === 0) continue

    md += `## \`${file}\`\n\n`
    const first = blocks[0]
    const moduleTag = first.tags.find(t => t.tag === 'module')
    const desc = moduleTag
      ? moduleTag.name || first.description
      : first.description
    if (desc) md += `${desc.trim()}\n\n`

    for (const b of blocks) {
      const fn = b.tags.find(t => t.tag === 'function' || t.tag === 'class')
      if (!fn) continue
      const name = fn.name || '(anonymous)'
      md += `### \`${name}\`\n\n`
      md += `${b.description.trim()}\n\n`
      const params = b.tags.filter(t => t.tag === 'param')
      if (params.length) {
        md += '**Parameters:**\n\n'
        for (const p of params) {
          md += `- \`${p.name}\` {${p.type}} — ${p.description}\n`
        }
        md += '\n'
      }
      const ret = b.tags.find(t => t.tag === 'returns' || t.tag === 'return')
      if (ret) {
        md += `**Returns:** {${ret.type}} — ${ret.description}\n\n`
      }
    }
  }

  await fs.writeFile('ARCHITECTURE.md', md, 'utf8')
  console.log('✅ ARCHITECTURE.md generated.')
}

extract().catch(err => {
  console.error(err)
  process.exit(1)
})
